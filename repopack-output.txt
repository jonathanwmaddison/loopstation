================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-02T01:02:24.003Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
app/
  favicon.ico
  globals.css
  layout.tsx
  page.tsx
components/
  Track.js
  WaveformVisualizer.js
pages/
  index.js
public/
  next.svg
  vercel.svg
.eslintrc.json
.gitignore
ai-code.txt
next.config.mjs
organize_nextjs_files.sh
package.json
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

================
File: app/page.tsx
================
'use client'
import React, { useState, useRef, useEffect } from 'react';
import Head from 'next/head';
import Track from '../components/Track';
import WaveformVisualizer from '../components/WaveformVisualizer';

const MAX_TRACKS = 4;

export default function Home() {
  const [tracks, setTracks] = useState([{ id: 1, recording: null, isRecording: false, isPlaying: false, volume: 1 }]);
  const [activeTrack, setActiveTrack] = useState(1);
  const [status, setStatus] = useState('Ready');

  const audioContext = useRef(null);
  const analyser = useRef(null);

  useEffect(() => {
    if (typeof window !== 'undefined') {
      audioContext.current = new (window.AudioContext || window.webkitAudioContext)();
      analyser.current = audioContext.current.createAnalyser();
      analyser.current.connect(audioContext.current.destination);
    }
    return () => {
      if (audioContext.current) {
        audioContext.current.close();
      }
    };
  }, []);

  const addTrack = () => {
    if (tracks.length < MAX_TRACKS) {
      setTracks([...tracks, { id: tracks.length + 1, recording: null, isRecording: false, isPlaying: false, volume: 1 }]);
    }
  };

  const removeTrack = (id) => {
    setTracks(tracks.filter(track => track.id !== id));
    if (activeTrack === id) {
      setActiveTrack(tracks[0].id);
    }
  };

  const updateTrack = (id, updates) => {
    setTracks(tracks.map(track => track.id === id ? { ...track, ...updates } : track));
  };

  const playAllTracks = () => {
    tracks.forEach(track => {
      if (track.recording) {
        const source = audioContext.current.createBufferSource();
        source.buffer = track.recording;
        const gainNode = audioContext.current.createGain();
        gainNode.gain.setValueAtTime(track.volume, audioContext.current.currentTime);
        source.connect(gainNode);
        gainNode.connect(analyser.current);
        source.loop = true;
        source.start();
        updateTrack(track.id, { isPlaying: true, source });
      }
    });
    setStatus('Playing all tracks');
  };

  const stopAllTracks = () => {
    tracks.forEach(track => {
      if (track.isPlaying && track.source) {
        track.source.stop();
        updateTrack(track.id, { isPlaying: false, source: null });
      }
    });
    setStatus('All tracks stopped');
  };

  return (
    <div className="container">
      <Head>
        <title>Next.js Multi-Track Looper</title>
        <meta name="description" content="A multi-track audio looper built with Next.js" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="main">
        <h1 className="title">Next.js Multi-Track Looper</h1>
        <div className="looper">
          <div className="tracks">
            {tracks.map(track => (
              <Track
                key={track.id}
                {...track}
                isActive={activeTrack === track.id}
                onRecord={(buffer) => updateTrack(track.id, { recording: buffer, isRecording: false })}
                onPlay={() => updateTrack(track.id, { isPlaying: true })}
                onStop={() => updateTrack(track.id, { isPlaying: false })}
                onVolumeChange={(volume) => updateTrack(track.id, { volume })}
                onActivate={() => setActiveTrack(track.id)}
                onRemove={() => removeTrack(track.id)}
                audioContext={audioContext.current}
                analyser={analyser.current}
              />
            ))}
          </div>
          {tracks.length < MAX_TRACKS && (
            <button onClick={addTrack} className="btn btn-secondary">Add Track</button>
          )}
          <div className="global-controls">
            <button onClick={playAllTracks} className="btn btn-primary">Play All</button>
            <button onClick={stopAllTracks} className="btn btn-primary">Stop All</button>
          </div>
          <div className="status">{status}</div>
          <WaveformVisualizer analyser={analyser.current} />
        </div>
      </main>

      <style jsx>{`
        .container {
          min-height: 100vh;
          padding: 0 0.5rem;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          background-color: #f0f2f5;
        }
        .main {
          padding: 2rem 0;
          flex: 1;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
        }
        .title {
          margin: 0 0 2rem;
          line-height: 1.15;
          font-size: 3rem;
          text-align: center;
          color: #333;
        }
        .looper {
          background-color: #fff;
          padding: 2rem;
          border-radius: 10px;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          width: 90%;
          max-width: 800px;
        }
        .tracks {
          display: flex;
          flex-direction: column;
          gap: 1rem;
          margin-bottom: 1rem;
        }
        .global-controls {
          display: flex;
          justify-content: center;
          gap: 1rem;
          margin-top: 1rem;
        }
        .btn {
          padding: 0.5rem 1rem;
          font-size: 1rem;
          cursor: pointer;
          border: none;
          border-radius: 5px;
          transition: background-color 0.3s, transform 0.1s;
        }
        .btn:active {
          transform: translateY(1px);
        }
        .btn-primary {
          background-color: #0070f3;
          color: white;
        }
        .btn-primary:hover {
          background-color: #0051cc;
        }
        .btn-secondary {
          background-color: #718096;
          color: white;
        }
        .btn-secondary:hover {
          background-color: #4a5568;
        }
        .status {
          margin-top: 1rem;
          text-align: center;
          font-weight: bold;
          color: #4a5568;
        }
      `}</style>
    </div>
  );
}

================
File: components/Track.js
================
import React, { useState, useRef } from 'react';

const Track = ({ id, isActive, onRecord, onPlay, onStop, onVolumeChange, onActivate, onRemove, audioContext, analyser }) => {
  const [isRecording, setIsRecording] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);
  const [volume, setVolume] = useState(1);
  const recorder = useRef(null);
  const source = useRef(null);

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      recorder.current = new MediaRecorder(stream);
      const chunks = [];
      recorder.current.ondataavailable = (e) => chunks.push(e.data);
      recorder.current.onstop = async () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        onRecord(audioBuffer);
      };
      recorder.current.start();
      setIsRecording(true);
    } catch (err) {
      console.error('Error starting recording:', err);
    }
  };

  const stopRecording = () => {
    if (recorder.current) {
      recorder.current.stop();
      setIsRecording(false);
    }
  };

  const playTrack = () => {
    if (source.current) {
      source.current = audioContext.createBufferSource();
      source.current.buffer = audioBuffer;
      const gainNode = audioContext.createGain();
      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      source.current.connect(gainNode);
      gainNode.connect(analyser);
      source.current.loop = true;
      source.current.start();
      setIsPlaying(true);
      onPlay();
    }
  };

  const stopTrack = () => {
    if (source.current) {
      source.current.stop();
      setIsPlaying(false);
      onStop();
    }
  };

  const handleVolumeChange = (e) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);
    onVolumeChange(newVolume);
  };

  return (
    <div className={`track ${isActive ? 'active' : ''}`}>
      <div className="track-header">
        <h3 className="track-title">Track {id}</h3>
        <button onClick={onRemove} className="btn btn-icon btn-remove" aria-label="Remove track">×</button>
      </div>
      <div className="track-controls">
        <button onClick={isRecording ? stopRecording : startRecording} className={`btn ${isRecording ? 'btn-danger' : 'btn-record'}`}>
          {isRecording ? 'Stop' : 'Record'}
        </button>
        <button onClick={isPlaying ? stopTrack : playTrack} className="btn btn-play" disabled={!source.current}>
          {isPlaying ? 'Stop' : 'Play'}
        </button>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value={volume}
          onChange={handleVolumeChange}
          className="volume-slider"
        />
        <button onClick={onActivate} className={`btn btn-activate ${isActive ? 'active' : ''}`}>Activate</button>
      </div>

      <style jsx>{`
        .track {
          background-color: #f7fafc;
          border: 1px solid #e2e8f0;
          border-radius: 8px;
          padding: 1rem;
          transition: all 0.3s ease;
        }
        .track.active {
          border-color: #4299e1;
          box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
        }
        .track-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.5rem;
        }
        .track-title {
          margin: 0;
          font-size: 1.2rem;
          color: #2d3748;
        }
        .track-controls {
          display: flex;
          flex-wrap: wrap;
          gap: 0.5rem;
          align-items: center;
        }
        .btn {
          padding: 0.5rem 1rem;
          font-size: 1rem;
          cursor: pointer;
          border: none;
          border-radius: 5px;
          transition: background-color 0.3s, transform 0.1s;
        }
        .btn:active {
          transform: translateY(1px);
        }
        .btn-record {
          background-color: #48bb78;
          color: white;
        }
        .btn-danger {
          background-color: #f56565;
          color: white;
        }
        .btn-play {
          background-color: #4299e1;
          color: white;
        }
        .btn-play:disabled {
          background-color: #a0aec0;
          cursor: not-allowed;
        }
        .btn-activate {
          background-color: #ed8936;
          color: white;
        }
        .btn-activate.active {
          background-color: #dd6b20;
        }
        .btn-icon {
          padding: 0.25rem 0.5rem;
          font-size: 1.2rem;
          line-height: 1;
        }
        .btn-remove {
          background-color: #e53e3e;
          color: white;
        }
        .volume-slider {
          width: 100px;
          margin: 0 0.5rem;
        }
      `}</style>
    </div>
  );
};

export default Track;

================
File: components/WaveformVisualizer.js
================
import React, { useRef, useEffect } from 'react';

const WaveformVisualizer = ({ analyser }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    if (!analyser) return;

    const canvas = canvasRef.current;
    const canvasCtx = canvas.getContext('2d');
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const draw = () => {
      requestAnimationFrame(draw);
      analyser.getByteTimeDomainData(dataArray);

      canvasCtx.fillStyle = 'rgb(200, 200, 200)';
      canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
      canvasCtx.lineWidth = 2;
      canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
      canvasCtx.beginPath();

      const sliceWidth = canvas.width * 1.0 / bufferLength;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] / 128.0;
        const y = v * canvas.height / 2;

        if (i === 0) {
          canvasCtx.moveTo(x, y);
        } else {
          canvasCtx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      canvasCtx.lineTo(canvas.width, canvas.height / 2);
      canvasCtx.stroke();
    };

    draw();
  }, [analyser]);

  return (
    <div className="waveform">
      <canvas ref={canvasRef} width="640" height="100"></canvas>
      <style jsx>{`
        .waveform {
          margin-top: 20px;
        }
      `}</style>
    </div>
  );
};

export default WaveformVisualizer;

================
File: pages/index.js
================
import React, { useState, useRef, useEffect } from 'react';
import Head from 'next/head';
import Track from '../components/Track';
import WaveformVisualizer from '../components/WaveformVisualizer';

const MAX_TRACKS = 4;

export default function Home() {
  const [tracks, setTracks] = useState([{ id: 1, recording: null, isRecording: false, isPlaying: false, volume: 1 }]);
  const [activeTrack, setActiveTrack] = useState(1);
  const [status, setStatus] = useState('Ready');

  const audioContext = useRef(null);
  const analyser = useRef(null);

  useEffect(() => {
    if (typeof window !== 'undefined') {
      audioContext.current = new (window.AudioContext || window.webkitAudioContext)();
      analyser.current = audioContext.current.createAnalyser();
      analyser.current.connect(audioContext.current.destination);
    }
    return () => {
      if (audioContext.current) {
        audioContext.current.close();
      }
    };
  }, []);

  const addTrack = () => {
    if (tracks.length < MAX_TRACKS) {
      setTracks([...tracks, { id: tracks.length + 1, recording: null, isRecording: false, isPlaying: false, volume: 1 }]);
    }
  };

  const removeTrack = (id) => {
    setTracks(tracks.filter(track => track.id !== id));
    if (activeTrack === id) {
      setActiveTrack(tracks[0].id);
    }
  };

  const updateTrack = (id, updates) => {
    setTracks(tracks.map(track => track.id === id ? { ...track, ...updates } : track));
  };

  const playAllTracks = () => {
    tracks.forEach(track => {
      if (track.recording) {
        const source = audioContext.current.createBufferSource();
        source.buffer = track.recording;
        const gainNode = audioContext.current.createGain();
        gainNode.gain.setValueAtTime(track.volume, audioContext.current.currentTime);
        source.connect(gainNode);
        gainNode.connect(analyser.current);
        source.loop = true;
        source.start();
        updateTrack(track.id, { isPlaying: true, source });
      }
    });
    setStatus('Playing all tracks');
  };

  const stopAllTracks = () => {
    tracks.forEach(track => {
      if (track.isPlaying && track.source) {
        track.source.stop();
        updateTrack(track.id, { isPlaying: false, source: null });
      }
    });
    setStatus('All tracks stopped');
  };

  return (
    <div>
      <Head>
        <title>Next.js Multi-Track Looper</title>
        <meta name="description" content="A multi-track audio looper built with Next.js" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="container">
        <h1>Next.js Multi-Track Looper</h1>
        <div className="looper">
          {tracks.map(track => (
            <Track
              key={track.id}
              {...track}
              isActive={activeTrack === track.id}
              onRecord={(buffer) => updateTrack(track.id, { recording: buffer, isRecording: false })}
              onPlay={() => updateTrack(track.id, { isPlaying: true })}
              onStop={() => updateTrack(track.id, { isPlaying: false })}
              onVolumeChange={(volume) => updateTrack(track.id, { volume })}
              onActivate={() => setActiveTrack(track.id)}
              onRemove={() => removeTrack(track.id)}
              audioContext={audioContext.current}
              analyser={analyser.current}
            />
          ))}
          {tracks.length < MAX_TRACKS && (
            <button onClick={addTrack} className="btn btn-secondary">Add Track</button>
          )}
          <div className="global-controls">
            <button onClick={playAllTracks} className="btn btn-primary">Play All</button>
            <button onClick={stopAllTracks} className="btn btn-primary">Stop All</button>
          </div>
          <div className="status">{status}</div>
          <WaveformVisualizer analyser={analyser.current} />
        </div>
      </main>

      <style jsx>{`
        .container {
          min-height: 100vh;
          padding: 0 0.5rem;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          font-family: Arial, sans-serif;
        }
        .looper {
          background-color: #fff;
          padding: 20px;
          border-radius: 10px;
          box-shadow: 0 0 10px rgba(0,0,0,0.1);
          text-align: center;
          width: 80%;
          max-width: 800px;
        }
        .btn {
          margin: 5px;
          padding: 10px 20px;
          font-size: 16px;
          cursor: pointer;
          color: white;
          border: none;
          border-radius: 5px;
          transition: background-color 0.3s;
        }
        .btn-primary {
          background-color: #0070f3;
        }
        .btn-secondary {
          background-color: #6c757d;
        }
        .global-controls {
          margin-top: 20px;
        }
        .status {
          margin-top: 20px;
          font-weight: bold;
        }
      `}</style>
    </div>
  );
}

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/vercel.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>

================
File: .eslintrc.json
================
{
  "extends": "next/core-web-vitals"
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: ai-code.txt
================
// pages/index.js
import React, { useState, useRef, useEffect } from 'react';
import Head from 'next/head';
import Track from '../components/Track';
import WaveformVisualizer from '../components/WaveformVisualizer';

const MAX_TRACKS = 4;

export default function Home() {
  const [tracks, setTracks] = useState([{ id: 1, recording: null, isRecording: false, isPlaying: false, volume: 1 }]);
  const [activeTrack, setActiveTrack] = useState(1);
  const [status, setStatus] = useState('Ready');

  const audioContext = useRef(null);
  const analyser = useRef(null);

  useEffect(() => {
    if (typeof window !== 'undefined') {
      audioContext.current = new (window.AudioContext || window.webkitAudioContext)();
      analyser.current = audioContext.current.createAnalyser();
      analyser.current.connect(audioContext.current.destination);
    }
    return () => {
      if (audioContext.current) {
        audioContext.current.close();
      }
    };
  }, []);

  const addTrack = () => {
    if (tracks.length < MAX_TRACKS) {
      setTracks([...tracks, { id: tracks.length + 1, recording: null, isRecording: false, isPlaying: false, volume: 1 }]);
    }
  };

  const removeTrack = (id) => {
    setTracks(tracks.filter(track => track.id !== id));
    if (activeTrack === id) {
      setActiveTrack(tracks[0].id);
    }
  };

  const updateTrack = (id, updates) => {
    setTracks(tracks.map(track => track.id === id ? { ...track, ...updates } : track));
  };

  const playAllTracks = () => {
    tracks.forEach(track => {
      if (track.recording) {
        const source = audioContext.current.createBufferSource();
        source.buffer = track.recording;
        const gainNode = audioContext.current.createGain();
        gainNode.gain.setValueAtTime(track.volume, audioContext.current.currentTime);
        source.connect(gainNode);
        gainNode.connect(analyser.current);
        source.loop = true;
        source.start();
        updateTrack(track.id, { isPlaying: true, source });
      }
    });
    setStatus('Playing all tracks');
  };

  const stopAllTracks = () => {
    tracks.forEach(track => {
      if (track.isPlaying && track.source) {
        track.source.stop();
        updateTrack(track.id, { isPlaying: false, source: null });
      }
    });
    setStatus('All tracks stopped');
  };

  return (
    <div>
      <Head>
        <title>Next.js Multi-Track Looper</title>
        <meta name="description" content="A multi-track audio looper built with Next.js" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="container">
        <h1>Next.js Multi-Track Looper</h1>
        <div className="looper">
          {tracks.map(track => (
            <Track
              key={track.id}
              {...track}
              isActive={activeTrack === track.id}
              onRecord={(buffer) => updateTrack(track.id, { recording: buffer, isRecording: false })}
              onPlay={() => updateTrack(track.id, { isPlaying: true })}
              onStop={() => updateTrack(track.id, { isPlaying: false })}
              onVolumeChange={(volume) => updateTrack(track.id, { volume })}
              onActivate={() => setActiveTrack(track.id)}
              onRemove={() => removeTrack(track.id)}
              audioContext={audioContext.current}
              analyser={analyser.current}
            />
          ))}
          {tracks.length < MAX_TRACKS && (
            <button onClick={addTrack} className="btn btn-secondary">Add Track</button>
          )}
          <div className="global-controls">
            <button onClick={playAllTracks} className="btn btn-primary">Play All</button>
            <button onClick={stopAllTracks} className="btn btn-primary">Stop All</button>
          </div>
          <div className="status">{status}</div>
          <WaveformVisualizer analyser={analyser.current} />
        </div>
      </main>

      <style jsx>{`
        .container {
          min-height: 100vh;
          padding: 0 0.5rem;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          font-family: Arial, sans-serif;
        }
        .looper {
          background-color: #fff;
          padding: 20px;
          border-radius: 10px;
          box-shadow: 0 0 10px rgba(0,0,0,0.1);
          text-align: center;
          width: 80%;
          max-width: 800px;
        }
        .btn {
          margin: 5px;
          padding: 10px 20px;
          font-size: 16px;
          cursor: pointer;
          color: white;
          border: none;
          border-radius: 5px;
          transition: background-color 0.3s;
        }
        .btn-primary {
          background-color: #0070f3;
        }
        .btn-secondary {
          background-color: #6c757d;
        }
        .global-controls {
          margin-top: 20px;
        }
        .status {
          margin-top: 20px;
          font-weight: bold;
        }
      `}</style>
    </div>
  );
}

// components/Track.js
import React, { useState, useRef } from 'react';

const Track = ({ id, isActive, onRecord, onPlay, onStop, onVolumeChange, onActivate, onRemove, audioContext, analyser }) => {
  const [isRecording, setIsRecording] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);
  const [volume, setVolume] = useState(1);
  const recorder = useRef(null);
  const source = useRef(null);

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      recorder.current = new MediaRecorder(stream);
      const chunks = [];
      recorder.current.ondataavailable = (e) => chunks.push(e.data);
      recorder.current.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        onRecord(audioBuffer);
      };
      recorder.current.start();
      setIsRecording(true);
    } catch (err) {
      console.error('Error starting recording:', err);
    }
  };

  const stopRecording = () => {
    if (recorder.current) {
      recorder.current.stop();
      setIsRecording(false);
    }
  };

  const playTrack = () => {
    if (source.current) {
      source.current = audioContext.createBufferSource();
      source.current.buffer = audioBuffer;
      const gainNode = audioContext.createGain();
      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      source.current.connect(gainNode);
      gainNode.connect(analyser);
      source.current.loop = true;
      source.current.start();
      setIsPlaying(true);
      onPlay();
    }
  };

  const stopTrack = () => {
    if (source.current) {
      source.current.stop();
      setIsPlaying(false);
      onStop();
    }
  };

  const handleVolumeChange = (e) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);
    onVolumeChange(newVolume);
  };

  return (
    <div className={`track ${isActive ? 'active' : ''}`}>
      <h3>Track {id}</h3>
      <button onClick={isRecording ? stopRecording : startRecording} className="btn btn-danger">
        {isRecording ? 'Stop Recording' : 'Record'}
      </button>
      <button onClick={isPlaying ? stopTrack : playTrack} className="btn btn-primary" disabled={!source.current}>
        {isPlaying ? 'Stop' : 'Play'}
      </button>
      <input
        type="range"
        min="0"
        max="1"
        step="0.1"
        value={volume}
        onChange={handleVolumeChange}
        className="volume-slider"
      />
      <button onClick={onActivate} className="btn btn-secondary">Activate</button>
      <button onClick={onRemove} className="btn btn-warning">Remove</button>

      <style jsx>{`
        .track {
          border: 1px solid #ddd;
          padding: 10px;
          margin-bottom: 10px;
          border-radius: 5px;
        }
        .active {
          border-color: #0070f3;
        }
        .btn {
          margin: 0 5px;
        }
        .volume-slider {
          width: 100px;
          margin: 0 10px;
        }
      `}</style>
    </div>
  );
};

export default Track;

// components/WaveformVisualizer.js
import React, { useRef, useEffect } from 'react';

const WaveformVisualizer = ({ analyser }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    if (!analyser) return;

    const canvas = canvasRef.current;
    const canvasCtx = canvas.getContext('2d');
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const draw = () => {
      requestAnimationFrame(draw);
      analyser.getByteTimeDomainData(dataArray);

      canvasCtx.fillStyle = 'rgb(200, 200, 200)';
      canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
      canvasCtx.lineWidth = 2;
      canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
      canvasCtx.beginPath();

      const sliceWidth = canvas.width * 1.0 / bufferLength;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] / 128.0;
        const y = v * canvas.height / 2;

        if (i === 0) {
          canvasCtx.moveTo(x, y);
        } else {
          canvasCtx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      canvasCtx.lineTo(canvas.width, canvas.height / 2);
      canvasCtx.stroke();
    };

    draw();
  }, [analyser]);

  return (
    <div className="waveform">
      <canvas ref={canvasRef} width="640" height="100"></canvas>
      <style jsx>{`
        .waveform {
          margin-top: 20px;
        }
      `}</style>
    </div>
  );
};

export default WaveformVisualizer;

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

================
File: organize_nextjs_files.sh
================
#!/bin/bash

# Check if a filename was provided
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <filename>"
    exit 1
fi

input_file="$1"

# Check if the file exists
if [ ! -f "$input_file" ]; then
    echo "Error: File '$input_file' not found."
    exit 1
fi

# Function to create a file with content
create_file() {
    local filepath="$1"
    local content="$2"
    mkdir -p "$(dirname "$filepath")"
    echo "$content" > "$filepath"
    echo "Created file: $filepath"
}

# Process the input file
current_file=""
content=""

while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line == "//"* ]]; then
        # New file starts
        if [ -n "$current_file" ]; then
            create_file "$current_file" "$content"
            content=""
        fi
        current_file=$(echo "$line" | sed 's/\/\/ *//')
    else
        # Append to content
        content+="$line"$'\n'
    fi
done < "$input_file"

# Create the last file
if [ -n "$current_file" ]; then
    create_file "$current_file" "$content"
fi

echo "File organization complete!"

================
File: package.json
================
{
  "name": "loopstation",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.2.7"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "eslint": "^8",
    "eslint-config-next": "14.2.7"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: README.md
================
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic":
          "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
    },
  },
  plugins: [],
};
export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
